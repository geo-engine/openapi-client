/* tslint:disable */
/* eslint-disable */
/**
 * Geo Engine API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.8.0
 * Contact: dev@geoengine.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AutoCreateDataset,
  CreateDataset,
  Dataset,
  DatasetListing,
  DatasetNameResponse,
  ErrorResponse,
  MetaDataDefinition,
  MetaDataSuggestion,
  OrderBy,
  Provenances,
  SuggestMetaData,
  Symbology,
  UpdateDataset,
  Volume,
  VolumeFileLayersResponse,
} from '../models/index';
import {
    AutoCreateDatasetFromJSON,
    AutoCreateDatasetToJSON,
    CreateDatasetFromJSON,
    CreateDatasetToJSON,
    DatasetFromJSON,
    DatasetToJSON,
    DatasetListingFromJSON,
    DatasetListingToJSON,
    DatasetNameResponseFromJSON,
    DatasetNameResponseToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    MetaDataDefinitionFromJSON,
    MetaDataDefinitionToJSON,
    MetaDataSuggestionFromJSON,
    MetaDataSuggestionToJSON,
    OrderByFromJSON,
    OrderByToJSON,
    ProvenancesFromJSON,
    ProvenancesToJSON,
    SuggestMetaDataFromJSON,
    SuggestMetaDataToJSON,
    SymbologyFromJSON,
    SymbologyToJSON,
    UpdateDatasetFromJSON,
    UpdateDatasetToJSON,
    VolumeFromJSON,
    VolumeToJSON,
    VolumeFileLayersResponseFromJSON,
    VolumeFileLayersResponseToJSON,
} from '../models/index';

export interface AutoCreateDatasetHandlerRequest {
    autoCreateDataset: AutoCreateDataset;
}

export interface CreateDatasetHandlerRequest {
    createDataset: CreateDataset;
}

export interface DeleteDatasetHandlerRequest {
    dataset: string;
}

export interface GetDatasetHandlerRequest {
    dataset: string;
}

export interface GetLoadingInfoHandlerRequest {
    dataset: string;
}

export interface ListDatasetsHandlerRequest {
    order: OrderBy;
    offset: number;
    limit: number;
    filter?: string;
    tags?: Array<string>;
}

export interface ListVolumeFileLayersHandlerRequest {
    volumeName: string;
    fileName: string;
}

export interface SuggestMetaDataHandlerRequest {
    suggestMetaData: SuggestMetaData;
}

export interface UpdateDatasetHandlerRequest {
    dataset: string;
    updateDataset: UpdateDataset;
}

export interface UpdateDatasetProvenanceHandlerRequest {
    dataset: string;
    provenances: Provenances;
}

export interface UpdateDatasetSymbologyHandlerRequest {
    dataset: string;
    symbology: Symbology;
}

export interface UpdateLoadingInfoHandlerRequest {
    dataset: string;
    metaDataDefinition: MetaDataDefinition;
}

/**
 * 
 */
export class DatasetsApi extends runtime.BaseAPI {

    /**
     * Creates a new dataset using previously uploaded files. The format of the files will be automatically detected when possible.
     */
    async autoCreateDatasetHandlerRaw(requestParameters: AutoCreateDatasetHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DatasetNameResponse>> {
        if (requestParameters['autoCreateDataset'] == null) {
            throw new runtime.RequiredError(
                'autoCreateDataset',
                'Required parameter "autoCreateDataset" was null or undefined when calling autoCreateDatasetHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/dataset/auto`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AutoCreateDatasetToJSON(requestParameters['autoCreateDataset']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DatasetNameResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new dataset using previously uploaded files. The format of the files will be automatically detected when possible.
     */
    async autoCreateDatasetHandler(requestParameters: AutoCreateDatasetHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DatasetNameResponse> {
        const response = await this.autoCreateDatasetHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new dataset referencing files. Users can reference previously uploaded files. Admins can reference files from a volume.
     */
    async createDatasetHandlerRaw(requestParameters: CreateDatasetHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DatasetNameResponse>> {
        if (requestParameters['createDataset'] == null) {
            throw new runtime.RequiredError(
                'createDataset',
                'Required parameter "createDataset" was null or undefined when calling createDatasetHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/dataset`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateDatasetToJSON(requestParameters['createDataset']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DatasetNameResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new dataset referencing files. Users can reference previously uploaded files. Admins can reference files from a volume.
     */
    async createDatasetHandler(requestParameters: CreateDatasetHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DatasetNameResponse> {
        const response = await this.createDatasetHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a dataset
     */
    async deleteDatasetHandlerRaw(requestParameters: DeleteDatasetHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['dataset'] == null) {
            throw new runtime.RequiredError(
                'dataset',
                'Required parameter "dataset" was null or undefined when calling deleteDatasetHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/dataset/{dataset}`;
        urlPath = urlPath.replace(`{${"dataset"}}`, encodeURIComponent(String(requestParameters['dataset'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a dataset
     */
    async deleteDatasetHandler(requestParameters: DeleteDatasetHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteDatasetHandlerRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves details about a dataset using the internal name.
     */
    async getDatasetHandlerRaw(requestParameters: GetDatasetHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Dataset>> {
        if (requestParameters['dataset'] == null) {
            throw new runtime.RequiredError(
                'dataset',
                'Required parameter "dataset" was null or undefined when calling getDatasetHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/dataset/{dataset}`;
        urlPath = urlPath.replace(`{${"dataset"}}`, encodeURIComponent(String(requestParameters['dataset'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DatasetFromJSON(jsonValue));
    }

    /**
     * Retrieves details about a dataset using the internal name.
     */
    async getDatasetHandler(requestParameters: GetDatasetHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Dataset> {
        const response = await this.getDatasetHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the loading information of a dataset
     */
    async getLoadingInfoHandlerRaw(requestParameters: GetLoadingInfoHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MetaDataDefinition>> {
        if (requestParameters['dataset'] == null) {
            throw new runtime.RequiredError(
                'dataset',
                'Required parameter "dataset" was null or undefined when calling getLoadingInfoHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/dataset/{dataset}/loadingInfo`;
        urlPath = urlPath.replace(`{${"dataset"}}`, encodeURIComponent(String(requestParameters['dataset'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MetaDataDefinitionFromJSON(jsonValue));
    }

    /**
     * Retrieves the loading information of a dataset
     */
    async getLoadingInfoHandler(requestParameters: GetLoadingInfoHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MetaDataDefinition> {
        const response = await this.getLoadingInfoHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists available datasets.
     */
    async listDatasetsHandlerRaw(requestParameters: ListDatasetsHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DatasetListing>>> {
        if (requestParameters['order'] == null) {
            throw new runtime.RequiredError(
                'order',
                'Required parameter "order" was null or undefined when calling listDatasetsHandler().'
            );
        }

        if (requestParameters['offset'] == null) {
            throw new runtime.RequiredError(
                'offset',
                'Required parameter "offset" was null or undefined when calling listDatasetsHandler().'
            );
        }

        if (requestParameters['limit'] == null) {
            throw new runtime.RequiredError(
                'limit',
                'Required parameter "limit" was null or undefined when calling listDatasetsHandler().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['tags'] != null) {
            queryParameters['tags'] = requestParameters['tags'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/datasets`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DatasetListingFromJSON));
    }

    /**
     * Lists available datasets.
     */
    async listDatasetsHandler(requestParameters: ListDatasetsHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DatasetListing>> {
        const response = await this.listDatasetsHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the layers of a file in a volume.
     */
    async listVolumeFileLayersHandlerRaw(requestParameters: ListVolumeFileLayersHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VolumeFileLayersResponse>> {
        if (requestParameters['volumeName'] == null) {
            throw new runtime.RequiredError(
                'volumeName',
                'Required parameter "volumeName" was null or undefined when calling listVolumeFileLayersHandler().'
            );
        }

        if (requestParameters['fileName'] == null) {
            throw new runtime.RequiredError(
                'fileName',
                'Required parameter "fileName" was null or undefined when calling listVolumeFileLayersHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/dataset/volumes/{volume_name}/files/{file_name}/layers`;
        urlPath = urlPath.replace(`{${"volume_name"}}`, encodeURIComponent(String(requestParameters['volumeName'])));
        urlPath = urlPath.replace(`{${"file_name"}}`, encodeURIComponent(String(requestParameters['fileName'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VolumeFileLayersResponseFromJSON(jsonValue));
    }

    /**
     * List the layers of a file in a volume.
     */
    async listVolumeFileLayersHandler(requestParameters: ListVolumeFileLayersHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VolumeFileLayersResponse> {
        const response = await this.listVolumeFileLayersHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists available volumes.
     */
    async listVolumesHandlerRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Volume>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/dataset/volumes`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(VolumeFromJSON));
    }

    /**
     * Lists available volumes.
     */
    async listVolumesHandler(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Volume>> {
        const response = await this.listVolumesHandlerRaw(initOverrides);
        return await response.value();
    }

    /**
     * Inspects an upload and suggests metadata that can be used when creating a new dataset based on it. Tries to automatically detect the main file and layer name if not specified.
     */
    async suggestMetaDataHandlerRaw(requestParameters: SuggestMetaDataHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MetaDataSuggestion>> {
        if (requestParameters['suggestMetaData'] == null) {
            throw new runtime.RequiredError(
                'suggestMetaData',
                'Required parameter "suggestMetaData" was null or undefined when calling suggestMetaDataHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/dataset/suggest`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SuggestMetaDataToJSON(requestParameters['suggestMetaData']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MetaDataSuggestionFromJSON(jsonValue));
    }

    /**
     * Inspects an upload and suggests metadata that can be used when creating a new dataset based on it. Tries to automatically detect the main file and layer name if not specified.
     */
    async suggestMetaDataHandler(requestParameters: SuggestMetaDataHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MetaDataSuggestion> {
        const response = await this.suggestMetaDataHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update details about a dataset using the internal name.
     */
    async updateDatasetHandlerRaw(requestParameters: UpdateDatasetHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['dataset'] == null) {
            throw new runtime.RequiredError(
                'dataset',
                'Required parameter "dataset" was null or undefined when calling updateDatasetHandler().'
            );
        }

        if (requestParameters['updateDataset'] == null) {
            throw new runtime.RequiredError(
                'updateDataset',
                'Required parameter "updateDataset" was null or undefined when calling updateDatasetHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/dataset/{dataset}`;
        urlPath = urlPath.replace(`{${"dataset"}}`, encodeURIComponent(String(requestParameters['dataset'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateDatasetToJSON(requestParameters['updateDataset']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update details about a dataset using the internal name.
     */
    async updateDatasetHandler(requestParameters: UpdateDatasetHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateDatasetHandlerRaw(requestParameters, initOverrides);
    }

    /**
     */
    async updateDatasetProvenanceHandlerRaw(requestParameters: UpdateDatasetProvenanceHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['dataset'] == null) {
            throw new runtime.RequiredError(
                'dataset',
                'Required parameter "dataset" was null or undefined when calling updateDatasetProvenanceHandler().'
            );
        }

        if (requestParameters['provenances'] == null) {
            throw new runtime.RequiredError(
                'provenances',
                'Required parameter "provenances" was null or undefined when calling updateDatasetProvenanceHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/dataset/{dataset}/provenance`;
        urlPath = urlPath.replace(`{${"dataset"}}`, encodeURIComponent(String(requestParameters['dataset'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ProvenancesToJSON(requestParameters['provenances']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async updateDatasetProvenanceHandler(requestParameters: UpdateDatasetProvenanceHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateDatasetProvenanceHandlerRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the dataset\'s symbology
     */
    async updateDatasetSymbologyHandlerRaw(requestParameters: UpdateDatasetSymbologyHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['dataset'] == null) {
            throw new runtime.RequiredError(
                'dataset',
                'Required parameter "dataset" was null or undefined when calling updateDatasetSymbologyHandler().'
            );
        }

        if (requestParameters['symbology'] == null) {
            throw new runtime.RequiredError(
                'symbology',
                'Required parameter "symbology" was null or undefined when calling updateDatasetSymbologyHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/dataset/{dataset}/symbology`;
        urlPath = urlPath.replace(`{${"dataset"}}`, encodeURIComponent(String(requestParameters['dataset'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SymbologyToJSON(requestParameters['symbology']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the dataset\'s symbology
     */
    async updateDatasetSymbologyHandler(requestParameters: UpdateDatasetSymbologyHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateDatasetSymbologyHandlerRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the dataset\'s loading info
     */
    async updateLoadingInfoHandlerRaw(requestParameters: UpdateLoadingInfoHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['dataset'] == null) {
            throw new runtime.RequiredError(
                'dataset',
                'Required parameter "dataset" was null or undefined when calling updateLoadingInfoHandler().'
            );
        }

        if (requestParameters['metaDataDefinition'] == null) {
            throw new runtime.RequiredError(
                'metaDataDefinition',
                'Required parameter "metaDataDefinition" was null or undefined when calling updateLoadingInfoHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/dataset/{dataset}/loadingInfo`;
        urlPath = urlPath.replace(`{${"dataset"}}`, encodeURIComponent(String(requestParameters['dataset'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MetaDataDefinitionToJSON(requestParameters['metaDataDefinition']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the dataset\'s loading info
     */
    async updateLoadingInfoHandler(requestParameters: UpdateLoadingInfoHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateLoadingInfoHandlerRaw(requestParameters, initOverrides);
    }

}
