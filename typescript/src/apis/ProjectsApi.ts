/* tslint:disable */
/* eslint-disable */
/**
 * Geo Engine Pro API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.8.0
 * Contact: dev@geoengine.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddCollection200Response,
  CreateProject,
  OrderBy,
  Project,
  ProjectListing,
  ProjectVersion,
  UpdateProject,
} from '../models/index';
import {
    AddCollection200ResponseFromJSON,
    AddCollection200ResponseToJSON,
    CreateProjectFromJSON,
    CreateProjectToJSON,
    OrderByFromJSON,
    OrderByToJSON,
    ProjectFromJSON,
    ProjectToJSON,
    ProjectListingFromJSON,
    ProjectListingToJSON,
    ProjectVersionFromJSON,
    ProjectVersionToJSON,
    UpdateProjectFromJSON,
    UpdateProjectToJSON,
} from '../models/index';

export interface CreateProjectHandlerRequest {
    createProject: CreateProject;
}

export interface DeleteProjectHandlerRequest {
    project: string;
}

export interface ListProjectsHandlerRequest {
    order: OrderBy;
    offset: number;
    limit: number;
}

export interface LoadProjectLatestHandlerRequest {
    project: string;
}

export interface LoadProjectVersionHandlerRequest {
    project: string;
    version: string;
}

export interface ProjectVersionsHandlerRequest {
    project: string;
}

export interface UpdateProjectHandlerRequest {
    project: string;
    updateProject: UpdateProject;
}

/**
 * 
 */
export class ProjectsApi extends runtime.BaseAPI {

    /**
     * Create a new project for the user.
     * Create a new project for the user.
     */
    async createProjectHandlerRaw(requestParameters: CreateProjectHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddCollection200Response>> {
        if (requestParameters.createProject === null || requestParameters.createProject === undefined) {
            throw new runtime.RequiredError('createProject','Required parameter requestParameters.createProject was null or undefined when calling createProjectHandler.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/project`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateProjectToJSON(requestParameters.createProject),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddCollection200ResponseFromJSON(jsonValue));
    }

    /**
     * Create a new project for the user.
     * Create a new project for the user.
     */
    async createProjectHandler(requestParameters: CreateProjectHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddCollection200Response> {
        const response = await this.createProjectHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a project.
     * Deletes a project.
     */
    async deleteProjectHandlerRaw(requestParameters: DeleteProjectHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling deleteProjectHandler.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/project/{project}`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a project.
     * Deletes a project.
     */
    async deleteProjectHandler(requestParameters: DeleteProjectHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteProjectHandlerRaw(requestParameters, initOverrides);
    }

    /**
     * List all projects accessible to the user that match the selected criteria.
     * List all projects accessible to the user that match the selected criteria.
     */
    async listProjectsHandlerRaw(requestParameters: ListProjectsHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ProjectListing>>> {
        if (requestParameters.order === null || requestParameters.order === undefined) {
            throw new runtime.RequiredError('order','Required parameter requestParameters.order was null or undefined when calling listProjectsHandler.');
        }

        if (requestParameters.offset === null || requestParameters.offset === undefined) {
            throw new runtime.RequiredError('offset','Required parameter requestParameters.offset was null or undefined when calling listProjectsHandler.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling listProjectsHandler.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects`.replace(`{${"order"}}`, encodeURIComponent(String(requestParameters.order))).replace(`{${"offset"}}`, encodeURIComponent(String(requestParameters.offset))).replace(`{${"limit"}}`, encodeURIComponent(String(requestParameters.limit))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProjectListingFromJSON));
    }

    /**
     * List all projects accessible to the user that match the selected criteria.
     * List all projects accessible to the user that match the selected criteria.
     */
    async listProjectsHandler(requestParameters: ListProjectsHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ProjectListing>> {
        const response = await this.listProjectsHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves details about the latest version of a project.
     * Retrieves details about the latest version of a project.
     */
    async loadProjectLatestHandlerRaw(requestParameters: LoadProjectLatestHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling loadProjectLatestHandler.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/project/{project}`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     * Retrieves details about the latest version of a project.
     * Retrieves details about the latest version of a project.
     */
    async loadProjectLatestHandler(requestParameters: LoadProjectLatestHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Project> {
        const response = await this.loadProjectLatestHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves details about the given version of a project.
     * Retrieves details about the given version of a project.
     */
    async loadProjectVersionHandlerRaw(requestParameters: LoadProjectVersionHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling loadProjectVersionHandler.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling loadProjectVersionHandler.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/project/{project}/{version}`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"version"}}`, encodeURIComponent(String(requestParameters.version))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     * Retrieves details about the given version of a project.
     * Retrieves details about the given version of a project.
     */
    async loadProjectVersionHandler(requestParameters: LoadProjectVersionHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Project> {
        const response = await this.loadProjectVersionHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all available versions of a project.
     * Lists all available versions of a project.
     */
    async projectVersionsHandlerRaw(requestParameters: ProjectVersionsHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ProjectVersion>>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectVersionsHandler.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/project/{project}/versions`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProjectVersionFromJSON));
    }

    /**
     * Lists all available versions of a project.
     * Lists all available versions of a project.
     */
    async projectVersionsHandler(requestParameters: ProjectVersionsHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ProjectVersion>> {
        const response = await this.projectVersionsHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a project. This will create a new version.
     * Updates a project.
     */
    async updateProjectHandlerRaw(requestParameters: UpdateProjectHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling updateProjectHandler.');
        }

        if (requestParameters.updateProject === null || requestParameters.updateProject === undefined) {
            throw new runtime.RequiredError('updateProject','Required parameter requestParameters.updateProject was null or undefined when calling updateProjectHandler.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/project/{project}`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateProjectToJSON(requestParameters.updateProject),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates a project. This will create a new version.
     * Updates a project.
     */
    async updateProjectHandler(requestParameters: UpdateProjectHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateProjectHandlerRaw(requestParameters, initOverrides);
    }

}
