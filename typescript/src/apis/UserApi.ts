/* tslint:disable */
/* eslint-disable */
/**
 * Geo Engine API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.9.0
 * Contact: dev@geoengine.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddRole,
  ComputationQuota,
  DataUsage,
  DataUsageSummary,
  IdResponse,
  OperatorQuota,
  Quota,
  RoleDescription,
  UpdateQuota,
  UsageSummaryGranularity,
} from '../models/index';
import {
    AddRoleFromJSON,
    AddRoleToJSON,
    ComputationQuotaFromJSON,
    ComputationQuotaToJSON,
    DataUsageFromJSON,
    DataUsageToJSON,
    DataUsageSummaryFromJSON,
    DataUsageSummaryToJSON,
    IdResponseFromJSON,
    IdResponseToJSON,
    OperatorQuotaFromJSON,
    OperatorQuotaToJSON,
    QuotaFromJSON,
    QuotaToJSON,
    RoleDescriptionFromJSON,
    RoleDescriptionToJSON,
    UpdateQuotaFromJSON,
    UpdateQuotaToJSON,
    UsageSummaryGranularityFromJSON,
    UsageSummaryGranularityToJSON,
} from '../models/index';

export interface AddRoleHandlerRequest {
    addRole: AddRole;
}

export interface AssignRoleHandlerRequest {
    user: string;
    role: string;
}

export interface ComputationQuotaHandlerRequest {
    computation: string;
}

export interface ComputationsQuotaHandlerRequest {
    offset: number;
    limit: number;
}

export interface DataUsageHandlerRequest {
    offset: number;
    limit: number;
}

export interface DataUsageSummaryHandlerRequest {
    granularity: UsageSummaryGranularity;
    offset: number;
    limit: number;
    dataset?: string | null;
}

export interface GetRoleByNameHandlerRequest {
    name: string;
}

export interface GetUserQuotaHandlerRequest {
    user: string;
}

export interface RemoveRoleHandlerRequest {
    role: string;
}

export interface RevokeRoleHandlerRequest {
    user: string;
    role: string;
}

export interface UpdateUserQuotaHandlerRequest {
    user: string;
    updateQuota: UpdateQuota;
}

/**
 * 
 */
export class UserApi extends runtime.BaseAPI {

    /**
     * Add a new role. Requires admin privilige.
     */
    async addRoleHandlerRaw(requestParameters: AddRoleHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['addRole'] == null) {
            throw new runtime.RequiredError(
                'addRole',
                'Required parameter "addRole" was null or undefined when calling addRoleHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/roles`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AddRoleToJSON(requestParameters['addRole']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Add a new role. Requires admin privilige.
     */
    async addRoleHandler(requestParameters: AddRoleHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.addRoleHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Assign a role to a user. Requires admin privilige.
     */
    async assignRoleHandlerRaw(requestParameters: AssignRoleHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling assignRoleHandler().'
            );
        }

        if (requestParameters['role'] == null) {
            throw new runtime.RequiredError(
                'role',
                'Required parameter "role" was null or undefined when calling assignRoleHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/users/{user}/roles/{role}`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters['role']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Assign a role to a user. Requires admin privilige.
     */
    async assignRoleHandler(requestParameters: AssignRoleHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.assignRoleHandlerRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the quota used by computation with the given computation id
     */
    async computationQuotaHandlerRaw(requestParameters: ComputationQuotaHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<OperatorQuota>>> {
        if (requestParameters['computation'] == null) {
            throw new runtime.RequiredError(
                'computation',
                'Required parameter "computation" was null or undefined when calling computationQuotaHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/quota/computations/{computation}`.replace(`{${"computation"}}`, encodeURIComponent(String(requestParameters['computation']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OperatorQuotaFromJSON));
    }

    /**
     * Retrieves the quota used by computation with the given computation id
     */
    async computationQuotaHandler(requestParameters: ComputationQuotaHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<OperatorQuota>> {
        const response = await this.computationQuotaHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the quota used by computations
     */
    async computationsQuotaHandlerRaw(requestParameters: ComputationsQuotaHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ComputationQuota>>> {
        if (requestParameters['offset'] == null) {
            throw new runtime.RequiredError(
                'offset',
                'Required parameter "offset" was null or undefined when calling computationsQuotaHandler().'
            );
        }

        if (requestParameters['limit'] == null) {
            throw new runtime.RequiredError(
                'limit',
                'Required parameter "limit" was null or undefined when calling computationsQuotaHandler().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/quota/computations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ComputationQuotaFromJSON));
    }

    /**
     * Retrieves the quota used by computations
     */
    async computationsQuotaHandler(requestParameters: ComputationsQuotaHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ComputationQuota>> {
        const response = await this.computationsQuotaHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the data usage
     */
    async dataUsageHandlerRaw(requestParameters: DataUsageHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DataUsage>>> {
        if (requestParameters['offset'] == null) {
            throw new runtime.RequiredError(
                'offset',
                'Required parameter "offset" was null or undefined when calling dataUsageHandler().'
            );
        }

        if (requestParameters['limit'] == null) {
            throw new runtime.RequiredError(
                'limit',
                'Required parameter "limit" was null or undefined when calling dataUsageHandler().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/quota/dataUsage`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DataUsageFromJSON));
    }

    /**
     * Retrieves the data usage
     */
    async dataUsageHandler(requestParameters: DataUsageHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DataUsage>> {
        const response = await this.dataUsageHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the data usage summary
     */
    async dataUsageSummaryHandlerRaw(requestParameters: DataUsageSummaryHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DataUsageSummary>>> {
        if (requestParameters['granularity'] == null) {
            throw new runtime.RequiredError(
                'granularity',
                'Required parameter "granularity" was null or undefined when calling dataUsageSummaryHandler().'
            );
        }

        if (requestParameters['offset'] == null) {
            throw new runtime.RequiredError(
                'offset',
                'Required parameter "offset" was null or undefined when calling dataUsageSummaryHandler().'
            );
        }

        if (requestParameters['limit'] == null) {
            throw new runtime.RequiredError(
                'limit',
                'Required parameter "limit" was null or undefined when calling dataUsageSummaryHandler().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['granularity'] != null) {
            queryParameters['granularity'] = requestParameters['granularity'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['dataset'] != null) {
            queryParameters['dataset'] = requestParameters['dataset'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/quota/dataUsage/summary`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DataUsageSummaryFromJSON));
    }

    /**
     * Retrieves the data usage summary
     */
    async dataUsageSummaryHandler(requestParameters: DataUsageSummaryHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DataUsageSummary>> {
        const response = await this.dataUsageSummaryHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get role by name
     */
    async getRoleByNameHandlerRaw(requestParameters: GetRoleByNameHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRoleByNameHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/roles/byName/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Get role by name
     */
    async getRoleByNameHandler(requestParameters: GetRoleByNameHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IdResponse> {
        const response = await this.getRoleByNameHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query roles for the current user.
     */
    async getRoleDescriptionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RoleDescription>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/user/roles/descriptions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleDescriptionFromJSON));
    }

    /**
     * Query roles for the current user.
     */
    async getRoleDescriptions(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RoleDescription>> {
        const response = await this.getRoleDescriptionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the available and used quota of a specific user.
     */
    async getUserQuotaHandlerRaw(requestParameters: GetUserQuotaHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Quota>> {
        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling getUserQuotaHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/quotas/{user}`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuotaFromJSON(jsonValue));
    }

    /**
     * Retrieves the available and used quota of a specific user.
     */
    async getUserQuotaHandler(requestParameters: GetUserQuotaHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Quota> {
        const response = await this.getUserQuotaHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the available and used quota of the current user.
     */
    async quotaHandlerRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Quota>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/quota`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuotaFromJSON(jsonValue));
    }

    /**
     * Retrieves the available and used quota of the current user.
     */
    async quotaHandler(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Quota> {
        const response = await this.quotaHandlerRaw(initOverrides);
        return await response.value();
    }

    /**
     * Remove a role. Requires admin privilige.
     */
    async removeRoleHandlerRaw(requestParameters: RemoveRoleHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['role'] == null) {
            throw new runtime.RequiredError(
                'role',
                'Required parameter "role" was null or undefined when calling removeRoleHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/roles/{role}`.replace(`{${"role"}}`, encodeURIComponent(String(requestParameters['role']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a role. Requires admin privilige.
     */
    async removeRoleHandler(requestParameters: RemoveRoleHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeRoleHandlerRaw(requestParameters, initOverrides);
    }

    /**
     * Revoke a role from a user. Requires admin privilige.
     */
    async revokeRoleHandlerRaw(requestParameters: RevokeRoleHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling revokeRoleHandler().'
            );
        }

        if (requestParameters['role'] == null) {
            throw new runtime.RequiredError(
                'role',
                'Required parameter "role" was null or undefined when calling revokeRoleHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/users/{user}/roles/{role}`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))).replace(`{${"role"}}`, encodeURIComponent(String(requestParameters['role']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke a role from a user. Requires admin privilige.
     */
    async revokeRoleHandler(requestParameters: RevokeRoleHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokeRoleHandlerRaw(requestParameters, initOverrides);
    }

    /**
     * Update the available quota of a specific user.
     */
    async updateUserQuotaHandlerRaw(requestParameters: UpdateUserQuotaHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling updateUserQuotaHandler().'
            );
        }

        if (requestParameters['updateQuota'] == null) {
            throw new runtime.RequiredError(
                'updateQuota',
                'Required parameter "updateQuota" was null or undefined when calling updateUserQuotaHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("session_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/quotas/{user}`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateQuotaToJSON(requestParameters['updateQuota']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update the available quota of a specific user.
     */
    async updateUserQuotaHandler(requestParameters: UpdateUserQuotaHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateUserQuotaHandlerRaw(requestParameters, initOverrides);
    }

}
